<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>C++11 中的新特性</title>
<!-- 2013-10-30 三 01:52 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Exaos Lee" />
<meta  name="description" content="Level-2 for exporting to HTML"
 />
<link rel="stylesheet" title="Standard" href="../../assets/css/worg.css" type="text/css" />
<link rel="alternate stylesheet" title="Zenburn" href="../../assets/css/worg-zenburn.css" type="text/css" />
<link rel="alternate stylesheet" title="Classic" href="../../assets/css/worg-classic.css" type="text/css" />

<script type="text/javascript" src="http://orgmode.org/org-info.js">
/**
 *
 * @source: http://orgmode.org/org-info.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in http://orgmode.org/org-info.js.
 *
 * Copyright (C) 2012-2013  Sebastian Rose
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in http://orgmode.org/org-info.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "4");
org_html_manager.set("LINK_HOME", "../../index.html");
org_html_manager.set("LINK_UP", "../index.html");
org_html_manager.set("LOCAL_TOC", "1");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "0");
org_html_manager.set("VIEW", "content");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012  Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="../../index.html"> HOME </a>
</div><div id="content">
<h1 class="title">C++11 中的新特性</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Lambda 表达式</a></li>
<li><a href="#sec-2">自动类型推导和 <code>decltype</code></a></li>
<li><a href="#sec-3">统一的初始化语法</a></li>
<li><a href="#sec-4"><code>delete</code> 和 <code>default</code> 函数</a></li>
<li><a href="#sec-5">空指针 <code>nullptr</code></a></li>
<li><a href="#sec-6">构造函数委派</a></li>
<li><a href="#sec-7">右值引用</a></li>
<li><a href="#sec-8">STL 标准类库</a>
<ul>
<li><a href="#sec-8-1">线程库</a></li>
<li><a href="#sec-8-2">新的智能指针类</a></li>
<li><a href="#sec-8-3">新的算法</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
自从 1998 年 C++ 标准通过后，历经 13 年，新的标准 C++11 才完善。 C++ 发明人
Bjarne Stroustrup 说“C++11 感觉象一门新语言”。实际上，变化的确很大。不过，最初实现垃圾回收的 (GC) 的愿望仍然没有在新标准中体现。
</p>

<p>
核心语言特性变化分述如后，更多的参见 <a href="http://www.chenlq.net/cpp11-faq-chs">C++11 FAQ中文版</a>。
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Lambda 表达式</h2>
<div class="outline-text-2" id="text-1">
<p>
基本形式：
</p>
<pre class="example">
[capture] (parameters) -&gt; return-type {body}
</pre>

<p>
假如想计算字符串的大写字母个数，可用如下代码：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #63b8ff;">int</span> <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">main</span>()
{
  <span style="color: #63b8ff;">char</span> <span style="color: #7fffd4;">s</span>[]=<span style="color: #ffc1c1;">"Hello World!"</span>;
  <span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">Uppercase</span> = 0; <span style="color: #fa8072; font-style: italic;">//</span><span style="color: #ff7f24; font-style: italic;">modified by the lambda</span>
  for_each(s, s+<span style="color: #00ffff;">sizeof</span>(s), [&amp;Uppercase] (<span style="color: #63b8ff;">char</span> <span style="color: #7fffd4;">c</span>) {
      <span style="color: #00ffff;">if</span> (isupper(c))
        Uppercase++;
    });
  cout&lt;&lt; Uppercase&lt;&lt;<span style="color: #ffc1c1;">" uppercase letters in: "</span>&lt;&lt; s&lt;&lt;endl;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">自动类型推导和 <code>decltype</code></h2>
<div class="outline-text-2" id="text-2">
<p>
以 C++11 中可以不用指定对象类型即可声明一个对象，例如：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">auto</span> <span style="color: #63b8ff;">x</span> = 0;   <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">X &#20026; int &#22411;&#65292;&#22240;&#20026; 0 &#23646;&#20110; int &#31867;&#22411;</span>
<span style="color: #00ffff;">auto</span> <span style="color: #63b8ff;">c</span> = <span style="color: #ffc1c1;">'a'</span>; <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">char</span>
<span style="color: #00ffff;">auto</span> <span style="color: #63b8ff;">d</span> = 0.5; <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">double</span>
<span style="color: #00ffff;">auto</span> <span style="color: #63b8ff;">national_debt</span> = 14400000000000LL; <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">long long</span>
</pre>
</div>

<p>
当对象类型很冗长，或者是自动生成的 (如在模版中) 对象，比如：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #63b8ff;">void</span> <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">func</span>(<span style="color: #00ffff;">const</span> <span style="color: #63b8ff;">vector</span>&lt;<span style="color: #63b8ff;">int</span>&gt; &amp;<span style="color: #7fffd4;">vi</span>) {
  <span style="color: #8470ff; font-weight: bold;">vector</span>&lt;<span style="color: #63b8ff;">int</span>&gt;::<span style="color: #63b8ff;">const_iterator</span> <span style="color: #7fffd4;">ci</span>=vi.begin();
}
</pre>
</div>
<p>
可以将 iterator 声明改为：
</p>
<pre class="example">
auto ci = vi.begin();
</pre>

<p>
C++11 中提供了一种方法来返回对象或表达式的类型，即新的运算符 <code>decltype</code>:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">const</span> <span style="color: #63b8ff;">vector</span>&lt;<span style="color: #63b8ff;">int</span>&gt; <span style="color: #7fffd4;">vi</span>;
<span style="color: #00ffff;">typedef</span> <span style="color: #63b8ff;">decltype</span> (vi.begin()) CIT;
<span style="color: #63b8ff;">CIT</span> <span style="color: #7fffd4;">another_const_iterator</span>;
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">统一的初始化语法</h2>
<div class="outline-text-2" id="text-3">
<p>
C++ 至少有四种初始化表达方式，有些是相互重叠的。
</p>

<p>
参数的初始化象这样：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #8470ff; font-weight: bold;">std</span>::<span style="color: #63b8ff;">string</span> <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">s</span>(<span style="color: #ffc1c1;">"hello"</span>);
<span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">m</span>=<span style="color: #63b8ff;">int</span>(); <span style="color: #fa8072; font-style: italic;">//</span><span style="color: #ff7f24; font-style: italic;">default initialization</span>
</pre>
</div>

<p>
也可以使用 <code>=</code> 达到同样的目的：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #8470ff; font-weight: bold;">std</span>::<span style="color: #63b8ff;">string</span> <span style="color: #7fffd4;">s</span>=<span style="color: #ffc1c1;">"hello"</span>;
<span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">x</span>=5;
</pre>
</div>

<p>
对于 POD aggregates, 可使用花括号：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">arr</span>[4]={0,1,2,3};
<span style="color: #00ffff;">struct</span> <span style="color: #63b8ff;">tm</span> <span style="color: #7fffd4;">today</span>={0};
</pre>
</div>

<p>
最终，结构体使用成员初始化方法:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #63b8ff;">S</span> {
  <span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">x</span>;
  <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">S</span>(): x(0) {}
};
</pre>
</div>

<p>
方法丰富也容易混淆，这不仅仅是对初学者。在 C++11 中，使用统一的花括号标识：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #63b8ff;">C</span> {
  <span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">a</span>;
  <span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">b</span>;
<span style="color: #00ffff;">public</span>:
  <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">C</span>(<span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">i</span>, <span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">j</span>);
};

<span style="color: #63b8ff;">C</span> <span style="color: #7fffd4;">c</span> {0,0}; <span style="color: #fa8072; font-style: italic;">//</span><span style="color: #ff7f24; font-style: italic;">C++11 only. Equivalent to: C c(0,0);</span>

<span style="color: #63b8ff;">int</span>* <span style="color: #7fffd4;">a</span> = <span style="color: #00ffff;">new</span> <span style="color: #63b8ff;">int</span>[3] { 1, 2, 0 }; <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">C++11 only</span>

<span style="color: #00ffff;">class</span> <span style="color: #63b8ff;">X</span> {
  <span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">a</span>[4];
<span style="color: #00ffff;">public</span>:
  <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">X</span>() : a{1,2,3,4} {} <span style="color: #fa8072; font-style: italic;">//</span><span style="color: #ff7f24; font-style: italic;">C++11, member array initializer</span>
};
</pre>
</div>

<p>
对于容器类，可以对 <code>push_back()</code> 调用说再见了。在 C++11 中可以这样初始化容器类:
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">C++11 container initializer</span>
<span style="color: #63b8ff;">vector</span>&lt;<span style="color: #63b8ff;">string</span>&gt; <span style="color: #7fffd4;">vs</span> = { <span style="color: #ffc1c1;">"first"</span>, <span style="color: #ffc1c1;">"second"</span>, <span style="color: #ffc1c1;">"third"</span> };
<span style="color: #63b8ff;">map</span> <span style="color: #7fffd4;">singers</span> = {{ <span style="color: #ffc1c1;">"Lady Gaga"</span>, <span style="color: #ffc1c1;">"+1 (212) 555-7890"</span> },
               { <span style="color: #ffc1c1;">"Beyonce Knowles"</span>, <span style="color: #ffc1c1;">"+1 (212) 555-0987"</span> }};
</pre>
</div>

<p>
同时, C++11 还支持在类定义中初始化数据成员：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #63b8ff;">C</span> {
  <span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">a</span>=7; <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">C++11 only</span>
<span style="color: #00ffff;">public</span>:
  <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">C</span>();
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><code>delete</code> 和 <code>default</code> 函数</h2>
<div class="outline-text-2" id="text-4">
<p>
可以这种形式来声明函数：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #63b8ff;">A</span> {
  <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">A</span>() = <span style="color: #00ffff;">default</span>; <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">C++11</span>
  <span style="color: #00ffff;">virtual</span> ~<span style="color: #00fa9a; font-size: 110%; font-weight: bold;">A</span>()=<span style="color: #00ffff;">default</span>; <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">C++11</span>
};
</pre>
</div>
<p>
这样的函数称为 <b>默认函数</b>, 其中 <code>= default</code> 部分告诉编译器要生成默认实现的函数。
</p>

<p>
与默认函数相反的是 <b>禁用函数</b>:
</p>
<pre class="example">
int func() = delete;
</pre>

<p>
禁用函数可用于阻止对象拷贝等。比如：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">struct</span> <span style="color: #63b8ff;">NoCopy</span> {
  <span style="color: #63b8ff;">NoCopy</span> &amp; <span style="color: #00ffff;">operator</span> <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">=</span>( <span style="color: #00ffff;">const</span> <span style="color: #63b8ff;">NoCopy</span> &amp; ) = <span style="color: #00ffff;">delete</span>;
  <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">NoCopy</span> ( <span style="color: #00ffff;">const</span> <span style="color: #63b8ff;">NoCopy</span> &amp; ) = <span style="color: #00ffff;">delete</span>;
};
<span style="color: #63b8ff;">NoCopy</span> <span style="color: #7fffd4;">a</span>;
<span style="color: #63b8ff;">NoCopy</span> <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">b</span>(a); <span style="color: #fa8072; font-style: italic;">//</span><span style="color: #ff7f24; font-style: italic;">compilation error, copy ctor is deleted</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">空指针 <code>nullptr</code></h2>
<div class="outline-text-2" id="text-5">
<p>
空指针常量 <code>nullptr</code> 替换了问题多多的 <code>NULL</code> 宏。空指针 <code>nullptr</code> 是强类型的：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #63b8ff;">void</span> <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">f</span>(<span style="color: #63b8ff;">int</span>); <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">#1</span>
<span style="color: #63b8ff;">void</span> <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">f</span>(<span style="color: #63b8ff;">char</span> *);<span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">#2</span>
<span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">C++03</span>
f(0); <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">which f is called?</span>
<span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">C++11</span>
f(nullptr) <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">unambiguous, calls #2</span>
</pre>
</div>

<p>
<code>nullptr</code> 适用于所有的指针类别，包括函数指针和数据指针：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">const</span> <span style="color: #63b8ff;">char</span> *<span style="color: #7fffd4;">pc</span> = str.c_str(); <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">data pointers</span>
<span style="color: #00ffff;">if</span> (pc!=nullptr)
  cout &lt;&lt; pc &lt;&lt; endl;
<span style="color: #63b8ff;">int</span> (<span style="color: #8470ff; font-weight: bold;">A</span>::*<span style="color: #00fa9a; font-size: 110%; font-weight: bold;">pmf</span>)() = nullptr; <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">pointer to member function</span>
<span style="color: #63b8ff;">void</span> (*<span style="color: #00fa9a; font-size: 110%; font-weight: bold;">pmf</span>)() = nullptr; <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">pointer to function</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">构造函数委派</h2>
<div class="outline-text-2" id="text-6">
<p>
C++11 中的构造函数可以调用同一个类的另一个构造函数：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #00ffff;">class</span> <span style="color: #63b8ff;">M</span> { <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">C++11 delegating constructors</span>
  <span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">x</span>, <span style="color: #7fffd4;">y</span>;
  <span style="color: #63b8ff;">char</span> *<span style="color: #7fffd4;">p</span>;
<span style="color: #00ffff;">public</span>:
  <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">M</span>(<span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">v</span>) : x(v), y(0), p(<span style="color: #00ffff;">new</span> <span style="color: #63b8ff;">char</span> [MAX]) {} <span style="color: #fa8072; font-style: italic;">//</span><span style="color: #ff7f24; font-style: italic;">#1 target</span>
  <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">M</span>(): M(0) {cout&lt;&lt;<span style="color: #ffc1c1;">"delegating ctor"</span>&lt;&lt;endl;} <span style="color: #fa8072; font-style: italic;">//</span><span style="color: #ff7f24; font-style: italic;">#2 delegating</span>
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">右值引用</h2>
<div class="outline-text-2" id="text-7">
<p>
旧版本中赋值语句的右边永不会改变，这样做数值交换时往往效率很低，比如：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #63b8ff;">void</span> <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">naiveswap</span>(<span style="color: #63b8ff;">string</span> &amp;<span style="color: #7fffd4;">amp</span>;a, <span style="color: #63b8ff;">string</span> &amp;<span style="color: #7fffd4;">amp</span>;b) {
  <span style="color: #63b8ff;">string</span> <span style="color: #7fffd4;">temp</span> = a;
  a=b;
  b=temp;
}
</pre>
</div>
<p>
在交换数据时如果只是拷贝指针，而不需要再进行内存分配，这会很高效。比如：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #63b8ff;">void</span> <span style="color: #00fa9a; font-size: 110%; font-weight: bold;">moveswapstr</span>(<span style="color: #63b8ff;">string</span>&amp; <span style="color: #7fffd4;">empty</span>, <span style="color: #63b8ff;">string</span> &amp; <span style="color: #7fffd4;">filled</span>) {
  <span style="color: #fa8072; font-style: italic;">//</span><span style="color: #ff7f24; font-style: italic;">pseudo code, but you get the idea</span>
  <span style="color: #63b8ff;">size_t</span> <span style="color: #7fffd4;">sz</span>  =  empty.size();
  <span style="color: #00ffff;">const</span> <span style="color: #63b8ff;">char</span> *<span style="color: #7fffd4;">p</span> = empty.data();
  <span style="color: #fa8072; font-style: italic;">//</span><span style="color: #ff7f24; font-style: italic;">move filled's resources to empty</span>
  empty.setsize(filled.size());
  empty.setdata(filled.data());
  <span style="color: #fa8072; font-style: italic;">//</span><span style="color: #ff7f24; font-style: italic;">filled becomes empty</span>
  filled.setsize(sz);
  filled.setdata(p);
}
</pre>
</div>

<p>
C++11 中引入“右值引用” (R-value reference), 标识为：
</p>
<pre class="example">
typename &amp;&amp;
</pre>
<p>
它实现了 move semantics 操作，与上述的拷贝指针操作类似，不再需要重新分配内存。
C++11 STL 中广泛使用了右值引用，很多算法和容器的性能都被优化。
</p>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">STL 标准类库</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">线程库</h3>
<div class="outline-text-3" id="text-8-1">
<p>
线程类涉及两个部分内容：
</p>
<ol class="org-ol">
<li>多个线程在一个进程中共存的模型；
</li>
<li>对线程之间的交互提供支持。
</li>
</ol>

<p>
参考: <a href="http://www.devx.com/SpecialReports/Article/38883">Simpler Multithreading in C++0x</a>
</p>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">新的智能指针类</h3>
<div class="outline-text-3" id="text-8-2">
<p>
在 C++11 中，以前的 <code>auto_ptr</code> 用法被废弃，新引入了两个指针类：
</p>
<ul class="org-ul">
<li><code>shared_ptr</code> &#x2013; 单纯的引用计数指针。
</li>
<li><code>unique_ptr</code> &#x2013; 取代 <code>auto_ptr</code>.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">新的算法</h3>
<div class="outline-text-3" id="text-8-3">
<p>
定义了一些新的算法： <code>all_of()</code>, <code>any_of()</code>, <code>none_of()</code>. 例如，将判断函数
<code>ispositive()</code> 应用到列表的范围 <code>[first,first+n]</code> 中：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6495ed; font-style: italic;">#include</span> <span style="color: #ffc1c1;">&lt;algorithm&gt;</span>  <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">C++11 code</span>
<span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">&#20840;&#37096;&#20803;&#32032;&#37117;&#26159;&#27491;&#30340;&#65311;</span>
all_of(first, first+n, ispositive()); <span style="color: #fa8072; font-style: italic;">//</span><span style="color: #ff7f24; font-style: italic;">false</span>
<span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">&#33267;&#23569;&#26377;&#19968;&#20010;&#20026;&#27491;&#30340;&#65311;</span>
any_of(first, first+n, ispositive());<span style="color: #fa8072; font-style: italic;">//</span><span style="color: #ff7f24; font-style: italic;">true</span>
<span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">&#19968;&#20010;&#27491;&#30340;&#37117;&#27809;&#26377;&#21527;&#65311;</span>
none_of(first, first+n, ispositive()); <span style="color: #fa8072; font-style: italic;">//</span><span style="color: #ff7f24; font-style: italic;">false</span>
</pre>
</div>

<p>
新的 <code>copy_n</code> 算法。比如用 <code>copy_n()</code> 来拷贝数组中的 5 个元素到另一个中：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #6495ed; font-style: italic;">#include</span>
<span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">source</span>[5]={0,12,34,50,80};
<span style="color: #63b8ff;">int</span> <span style="color: #7fffd4;">target</span>[5];
<span style="color: #fa8072; font-style: italic;">//</span><span style="color: #ff7f24; font-style: italic;">copy 5 elements from source to target</span>
copy_n(source,5,target);
</pre>
</div>

<p>
新算法 <code>iota()</code> 可用于创建值递增的序列：给 <code>*first</code> 赋个初值，后序的每个元素逐个加一。比如：
</p>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #63b8ff;">include</span> &lt;numeric&gt;
<span style="color: #63b8ff;">int</span>  a[5] = {0};
<span style="color: #63b8ff;">char</span> <span style="color: #7fffd4;">c</span>[3] = {0};
iota(a, a+5, 10);  <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">&#23558; a &#21464;&#20026; {10,11,12,13,14}</span>
iota(c, c+3, <span style="color: #ffc1c1;">'a'</span>); <span style="color: #fa8072; font-style: italic;">// </span><span style="color: #ff7f24; font-style: italic;">&#23558; c &#21464;&#20026; {'a','b','c'}</span>
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

<script type="text/javascript" src="http://exaos.github.io/assets/js/pagetail.js"></script>
<div id="disqus_thread"></div>
<p>版权所有 ©2013: Exaos Lee | Date:  | Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.1), <a href="http://validator.w3.org/check?uri=referer">Validate</a>,
<a href="http://creativecommons.org/licenses/by-nc-sa/2.5/"><img src="http://i.creativecommons.org/l/by-nc-sa/2.5/cn/88x31.png" alt="88x31.png"/></a>
<p><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></p>
</div>
</body>
</html>
